// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: message.proto

#ifndef PROTOBUF_message_2eproto__INCLUDED
#define PROTOBUF_message_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)

namespace protobuf_message_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[11];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsJoinMeImpl();
void InitDefaultsJoinMe();
void InitDefaultsJoinImpl();
void InitDefaultsJoin();
void InitDefaultsNodeImpl();
void InitDefaultsNode();
void InitDefaultsListImpl();
void InitDefaultsList();
void InitDefaultsRoutingUpdate_RoutingEntryImpl();
void InitDefaultsRoutingUpdate_RoutingEntry();
void InitDefaultsRoutingUpdateImpl();
void InitDefaultsRoutingUpdate();
void InitDefaultsAllStateUpdateImpl();
void InitDefaultsAllStateUpdate();
void InitDefaultsGetValImpl();
void InitDefaultsGetVal();
void InitDefaultsSetValImpl();
void InitDefaultsSetVal();
void InitDefaultsMessageImpl();
void InitDefaultsMessage();
void InitDefaultsResponseImpl();
void InitDefaultsResponse();
inline void InitDefaults() {
  InitDefaultsJoinMe();
  InitDefaultsJoin();
  InitDefaultsNode();
  InitDefaultsList();
  InitDefaultsRoutingUpdate_RoutingEntry();
  InitDefaultsRoutingUpdate();
  InitDefaultsAllStateUpdate();
  InitDefaultsGetVal();
  InitDefaultsSetVal();
  InitDefaultsMessage();
  InitDefaultsResponse();
}
}  // namespace protobuf_message_2eproto
namespace message {
class AllStateUpdate;
class AllStateUpdateDefaultTypeInternal;
extern AllStateUpdateDefaultTypeInternal _AllStateUpdate_default_instance_;
class GetVal;
class GetValDefaultTypeInternal;
extern GetValDefaultTypeInternal _GetVal_default_instance_;
class Join;
class JoinDefaultTypeInternal;
extern JoinDefaultTypeInternal _Join_default_instance_;
class JoinMe;
class JoinMeDefaultTypeInternal;
extern JoinMeDefaultTypeInternal _JoinMe_default_instance_;
class List;
class ListDefaultTypeInternal;
extern ListDefaultTypeInternal _List_default_instance_;
class Message;
class MessageDefaultTypeInternal;
extern MessageDefaultTypeInternal _Message_default_instance_;
class Node;
class NodeDefaultTypeInternal;
extern NodeDefaultTypeInternal _Node_default_instance_;
class Response;
class ResponseDefaultTypeInternal;
extern ResponseDefaultTypeInternal _Response_default_instance_;
class RoutingUpdate;
class RoutingUpdateDefaultTypeInternal;
extern RoutingUpdateDefaultTypeInternal _RoutingUpdate_default_instance_;
class RoutingUpdate_RoutingEntry;
class RoutingUpdate_RoutingEntryDefaultTypeInternal;
extern RoutingUpdate_RoutingEntryDefaultTypeInternal _RoutingUpdate_RoutingEntry_default_instance_;
class SetVal;
class SetValDefaultTypeInternal;
extern SetValDefaultTypeInternal _SetVal_default_instance_;
}  // namespace message
namespace message {

// ===================================================================

class JoinMe : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:message.JoinMe) */ {
 public:
  JoinMe();
  virtual ~JoinMe();

  JoinMe(const JoinMe& from);

  inline JoinMe& operator=(const JoinMe& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  JoinMe(JoinMe&& from) noexcept
    : JoinMe() {
    *this = ::std::move(from);
  }

  inline JoinMe& operator=(JoinMe&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const JoinMe& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const JoinMe* internal_default_instance() {
    return reinterpret_cast<const JoinMe*>(
               &_JoinMe_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(JoinMe* other);
  friend void swap(JoinMe& a, JoinMe& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline JoinMe* New() const PROTOBUF_FINAL { return New(NULL); }

  JoinMe* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const JoinMe& from);
  void MergeFrom(const JoinMe& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(JoinMe* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string nodeID = 1;
  void clear_nodeid();
  static const int kNodeIDFieldNumber = 1;
  const ::std::string& nodeid() const;
  void set_nodeid(const ::std::string& value);
  #if LANG_CXX11
  void set_nodeid(::std::string&& value);
  #endif
  void set_nodeid(const char* value);
  void set_nodeid(const char* value, size_t size);
  ::std::string* mutable_nodeid();
  ::std::string* release_nodeid();
  void set_allocated_nodeid(::std::string* nodeid);

  // string IP = 2;
  void clear_ip();
  static const int kIPFieldNumber = 2;
  const ::std::string& ip() const;
  void set_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_ip(::std::string&& value);
  #endif
  void set_ip(const char* value);
  void set_ip(const char* value, size_t size);
  ::std::string* mutable_ip();
  ::std::string* release_ip();
  void set_allocated_ip(::std::string* ip);

  // string port = 3;
  void clear_port();
  static const int kPortFieldNumber = 3;
  const ::std::string& port() const;
  void set_port(const ::std::string& value);
  #if LANG_CXX11
  void set_port(::std::string&& value);
  #endif
  void set_port(const char* value);
  void set_port(const char* value, size_t size);
  ::std::string* mutable_port();
  ::std::string* release_port();
  void set_allocated_port(::std::string* port);

  // @@protoc_insertion_point(class_scope:message.JoinMe)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr nodeid_;
  ::google::protobuf::internal::ArenaStringPtr ip_;
  ::google::protobuf::internal::ArenaStringPtr port_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultsJoinMeImpl();
};
// -------------------------------------------------------------------

class Join : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:message.Join) */ {
 public:
  Join();
  virtual ~Join();

  Join(const Join& from);

  inline Join& operator=(const Join& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Join(Join&& from) noexcept
    : Join() {
    *this = ::std::move(from);
  }

  inline Join& operator=(Join&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Join& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Join* internal_default_instance() {
    return reinterpret_cast<const Join*>(
               &_Join_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(Join* other);
  friend void swap(Join& a, Join& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Join* New() const PROTOBUF_FINAL { return New(NULL); }

  Join* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Join& from);
  void MergeFrom(const Join& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Join* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string nodeID = 1;
  void clear_nodeid();
  static const int kNodeIDFieldNumber = 1;
  const ::std::string& nodeid() const;
  void set_nodeid(const ::std::string& value);
  #if LANG_CXX11
  void set_nodeid(::std::string&& value);
  #endif
  void set_nodeid(const char* value);
  void set_nodeid(const char* value, size_t size);
  ::std::string* mutable_nodeid();
  ::std::string* release_nodeid();
  void set_allocated_nodeid(::std::string* nodeid);

  // string IP = 2;
  void clear_ip();
  static const int kIPFieldNumber = 2;
  const ::std::string& ip() const;
  void set_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_ip(::std::string&& value);
  #endif
  void set_ip(const char* value);
  void set_ip(const char* value, size_t size);
  ::std::string* mutable_ip();
  ::std::string* release_ip();
  void set_allocated_ip(::std::string* ip);

  // string port = 3;
  void clear_port();
  static const int kPortFieldNumber = 3;
  const ::std::string& port() const;
  void set_port(const ::std::string& value);
  #if LANG_CXX11
  void set_port(::std::string&& value);
  #endif
  void set_port(const char* value);
  void set_port(const char* value, size_t size);
  ::std::string* mutable_port();
  ::std::string* release_port();
  void set_allocated_port(::std::string* port);

  // int32 row_index = 4;
  void clear_row_index();
  static const int kRowIndexFieldNumber = 4;
  ::google::protobuf::int32 row_index() const;
  void set_row_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:message.Join)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr nodeid_;
  ::google::protobuf::internal::ArenaStringPtr ip_;
  ::google::protobuf::internal::ArenaStringPtr port_;
  ::google::protobuf::int32 row_index_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultsJoinImpl();
};
// -------------------------------------------------------------------

class Node : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:message.Node) */ {
 public:
  Node();
  virtual ~Node();

  Node(const Node& from);

  inline Node& operator=(const Node& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Node(Node&& from) noexcept
    : Node() {
    *this = ::std::move(from);
  }

  inline Node& operator=(Node&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Node& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Node* internal_default_instance() {
    return reinterpret_cast<const Node*>(
               &_Node_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(Node* other);
  friend void swap(Node& a, Node& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Node* New() const PROTOBUF_FINAL { return New(NULL); }

  Node* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Node& from);
  void MergeFrom(const Node& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Node* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string nodeID = 1;
  void clear_nodeid();
  static const int kNodeIDFieldNumber = 1;
  const ::std::string& nodeid() const;
  void set_nodeid(const ::std::string& value);
  #if LANG_CXX11
  void set_nodeid(::std::string&& value);
  #endif
  void set_nodeid(const char* value);
  void set_nodeid(const char* value, size_t size);
  ::std::string* mutable_nodeid();
  ::std::string* release_nodeid();
  void set_allocated_nodeid(::std::string* nodeid);

  // string IP = 2;
  void clear_ip();
  static const int kIPFieldNumber = 2;
  const ::std::string& ip() const;
  void set_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_ip(::std::string&& value);
  #endif
  void set_ip(const char* value);
  void set_ip(const char* value, size_t size);
  ::std::string* mutable_ip();
  ::std::string* release_ip();
  void set_allocated_ip(::std::string* ip);

  // string port = 3;
  void clear_port();
  static const int kPortFieldNumber = 3;
  const ::std::string& port() const;
  void set_port(const ::std::string& value);
  #if LANG_CXX11
  void set_port(::std::string&& value);
  #endif
  void set_port(const char* value);
  void set_port(const char* value, size_t size);
  ::std::string* mutable_port();
  ::std::string* release_port();
  void set_allocated_port(::std::string* port);

  // @@protoc_insertion_point(class_scope:message.Node)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr nodeid_;
  ::google::protobuf::internal::ArenaStringPtr ip_;
  ::google::protobuf::internal::ArenaStringPtr port_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultsNodeImpl();
};
// -------------------------------------------------------------------

class List : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:message.List) */ {
 public:
  List();
  virtual ~List();

  List(const List& from);

  inline List& operator=(const List& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  List(List&& from) noexcept
    : List() {
    *this = ::std::move(from);
  }

  inline List& operator=(List&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const List& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const List* internal_default_instance() {
    return reinterpret_cast<const List*>(
               &_List_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(List* other);
  friend void swap(List& a, List& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline List* New() const PROTOBUF_FINAL { return New(NULL); }

  List* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const List& from);
  void MergeFrom(const List& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(List* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .message.Node node = 1;
  int node_size() const;
  void clear_node();
  static const int kNodeFieldNumber = 1;
  const ::message::Node& node(int index) const;
  ::message::Node* mutable_node(int index);
  ::message::Node* add_node();
  ::google::protobuf::RepeatedPtrField< ::message::Node >*
      mutable_node();
  const ::google::protobuf::RepeatedPtrField< ::message::Node >&
      node() const;

  // @@protoc_insertion_point(class_scope:message.List)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::message::Node > node_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultsListImpl();
};
// -------------------------------------------------------------------

class RoutingUpdate_RoutingEntry : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:message.RoutingUpdate.RoutingEntry) */ {
 public:
  RoutingUpdate_RoutingEntry();
  virtual ~RoutingUpdate_RoutingEntry();

  RoutingUpdate_RoutingEntry(const RoutingUpdate_RoutingEntry& from);

  inline RoutingUpdate_RoutingEntry& operator=(const RoutingUpdate_RoutingEntry& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RoutingUpdate_RoutingEntry(RoutingUpdate_RoutingEntry&& from) noexcept
    : RoutingUpdate_RoutingEntry() {
    *this = ::std::move(from);
  }

  inline RoutingUpdate_RoutingEntry& operator=(RoutingUpdate_RoutingEntry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RoutingUpdate_RoutingEntry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoutingUpdate_RoutingEntry* internal_default_instance() {
    return reinterpret_cast<const RoutingUpdate_RoutingEntry*>(
               &_RoutingUpdate_RoutingEntry_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(RoutingUpdate_RoutingEntry* other);
  friend void swap(RoutingUpdate_RoutingEntry& a, RoutingUpdate_RoutingEntry& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RoutingUpdate_RoutingEntry* New() const PROTOBUF_FINAL { return New(NULL); }

  RoutingUpdate_RoutingEntry* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RoutingUpdate_RoutingEntry& from);
  void MergeFrom(const RoutingUpdate_RoutingEntry& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RoutingUpdate_RoutingEntry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .message.List nodeList = 2;
  bool has_nodelist() const;
  void clear_nodelist();
  static const int kNodeListFieldNumber = 2;
  const ::message::List& nodelist() const;
  ::message::List* release_nodelist();
  ::message::List* mutable_nodelist();
  void set_allocated_nodelist(::message::List* nodelist);

  // int32 index = 1;
  void clear_index();
  static const int kIndexFieldNumber = 1;
  ::google::protobuf::int32 index() const;
  void set_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:message.RoutingUpdate.RoutingEntry)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::message::List* nodelist_;
  ::google::protobuf::int32 index_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultsRoutingUpdate_RoutingEntryImpl();
};
// -------------------------------------------------------------------

class RoutingUpdate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:message.RoutingUpdate) */ {
 public:
  RoutingUpdate();
  virtual ~RoutingUpdate();

  RoutingUpdate(const RoutingUpdate& from);

  inline RoutingUpdate& operator=(const RoutingUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RoutingUpdate(RoutingUpdate&& from) noexcept
    : RoutingUpdate() {
    *this = ::std::move(from);
  }

  inline RoutingUpdate& operator=(RoutingUpdate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RoutingUpdate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoutingUpdate* internal_default_instance() {
    return reinterpret_cast<const RoutingUpdate*>(
               &_RoutingUpdate_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(RoutingUpdate* other);
  friend void swap(RoutingUpdate& a, RoutingUpdate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RoutingUpdate* New() const PROTOBUF_FINAL { return New(NULL); }

  RoutingUpdate* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RoutingUpdate& from);
  void MergeFrom(const RoutingUpdate& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RoutingUpdate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef RoutingUpdate_RoutingEntry RoutingEntry;

  // accessors -------------------------------------------------------

  // repeated .message.RoutingUpdate.RoutingEntry routingEntires = 5;
  int routingentires_size() const;
  void clear_routingentires();
  static const int kRoutingEntiresFieldNumber = 5;
  const ::message::RoutingUpdate_RoutingEntry& routingentires(int index) const;
  ::message::RoutingUpdate_RoutingEntry* mutable_routingentires(int index);
  ::message::RoutingUpdate_RoutingEntry* add_routingentires();
  ::google::protobuf::RepeatedPtrField< ::message::RoutingUpdate_RoutingEntry >*
      mutable_routingentires();
  const ::google::protobuf::RepeatedPtrField< ::message::RoutingUpdate_RoutingEntry >&
      routingentires() const;

  // .message.List leaf = 3;
  bool has_leaf() const;
  void clear_leaf();
  static const int kLeafFieldNumber = 3;
  const ::message::List& leaf() const;
  ::message::List* release_leaf();
  ::message::List* mutable_leaf();
  void set_allocated_leaf(::message::List* leaf);

  // .message.List neighbours = 4;
  bool has_neighbours() const;
  void clear_neighbours();
  static const int kNeighboursFieldNumber = 4;
  const ::message::List& neighbours() const;
  ::message::List* release_neighbours();
  ::message::List* mutable_neighbours();
  void set_allocated_neighbours(::message::List* neighbours);

  // bool buddy = 1;
  void clear_buddy();
  static const int kBuddyFieldNumber = 1;
  bool buddy() const;
  void set_buddy(bool value);

  // bool terminal = 2;
  void clear_terminal();
  static const int kTerminalFieldNumber = 2;
  bool terminal() const;
  void set_terminal(bool value);

  // @@protoc_insertion_point(class_scope:message.RoutingUpdate)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::message::RoutingUpdate_RoutingEntry > routingentires_;
  ::message::List* leaf_;
  ::message::List* neighbours_;
  bool buddy_;
  bool terminal_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultsRoutingUpdateImpl();
};
// -------------------------------------------------------------------

class AllStateUpdate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:message.AllStateUpdate) */ {
 public:
  AllStateUpdate();
  virtual ~AllStateUpdate();

  AllStateUpdate(const AllStateUpdate& from);

  inline AllStateUpdate& operator=(const AllStateUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AllStateUpdate(AllStateUpdate&& from) noexcept
    : AllStateUpdate() {
    *this = ::std::move(from);
  }

  inline AllStateUpdate& operator=(AllStateUpdate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AllStateUpdate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AllStateUpdate* internal_default_instance() {
    return reinterpret_cast<const AllStateUpdate*>(
               &_AllStateUpdate_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(AllStateUpdate* other);
  friend void swap(AllStateUpdate& a, AllStateUpdate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AllStateUpdate* New() const PROTOBUF_FINAL { return New(NULL); }

  AllStateUpdate* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AllStateUpdate& from);
  void MergeFrom(const AllStateUpdate& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AllStateUpdate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .message.List leaf = 1;
  int leaf_size() const;
  void clear_leaf();
  static const int kLeafFieldNumber = 1;
  const ::message::List& leaf(int index) const;
  ::message::List* mutable_leaf(int index);
  ::message::List* add_leaf();
  ::google::protobuf::RepeatedPtrField< ::message::List >*
      mutable_leaf();
  const ::google::protobuf::RepeatedPtrField< ::message::List >&
      leaf() const;

  // repeated .message.List routingTable = 2;
  int routingtable_size() const;
  void clear_routingtable();
  static const int kRoutingTableFieldNumber = 2;
  const ::message::List& routingtable(int index) const;
  ::message::List* mutable_routingtable(int index);
  ::message::List* add_routingtable();
  ::google::protobuf::RepeatedPtrField< ::message::List >*
      mutable_routingtable();
  const ::google::protobuf::RepeatedPtrField< ::message::List >&
      routingtable() const;

  // repeated .message.List neighbours = 3;
  int neighbours_size() const;
  void clear_neighbours();
  static const int kNeighboursFieldNumber = 3;
  const ::message::List& neighbours(int index) const;
  ::message::List* mutable_neighbours(int index);
  ::message::List* add_neighbours();
  ::google::protobuf::RepeatedPtrField< ::message::List >*
      mutable_neighbours();
  const ::google::protobuf::RepeatedPtrField< ::message::List >&
      neighbours() const;

  // @@protoc_insertion_point(class_scope:message.AllStateUpdate)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::message::List > leaf_;
  ::google::protobuf::RepeatedPtrField< ::message::List > routingtable_;
  ::google::protobuf::RepeatedPtrField< ::message::List > neighbours_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultsAllStateUpdateImpl();
};
// -------------------------------------------------------------------

class GetVal : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:message.GetVal) */ {
 public:
  GetVal();
  virtual ~GetVal();

  GetVal(const GetVal& from);

  inline GetVal& operator=(const GetVal& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetVal(GetVal&& from) noexcept
    : GetVal() {
    *this = ::std::move(from);
  }

  inline GetVal& operator=(GetVal&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetVal& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetVal* internal_default_instance() {
    return reinterpret_cast<const GetVal*>(
               &_GetVal_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(GetVal* other);
  friend void swap(GetVal& a, GetVal& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetVal* New() const PROTOBUF_FINAL { return New(NULL); }

  GetVal* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetVal& from);
  void MergeFrom(const GetVal& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetVal* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // .message.Node node = 2;
  bool has_node() const;
  void clear_node();
  static const int kNodeFieldNumber = 2;
  const ::message::Node& node() const;
  ::message::Node* release_node();
  ::message::Node* mutable_node();
  void set_allocated_node(::message::Node* node);

  // @@protoc_insertion_point(class_scope:message.GetVal)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::message::Node* node_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultsGetValImpl();
};
// -------------------------------------------------------------------

class SetVal : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:message.SetVal) */ {
 public:
  SetVal();
  virtual ~SetVal();

  SetVal(const SetVal& from);

  inline SetVal& operator=(const SetVal& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SetVal(SetVal&& from) noexcept
    : SetVal() {
    *this = ::std::move(from);
  }

  inline SetVal& operator=(SetVal&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SetVal& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetVal* internal_default_instance() {
    return reinterpret_cast<const SetVal*>(
               &_SetVal_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(SetVal* other);
  friend void swap(SetVal& a, SetVal& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SetVal* New() const PROTOBUF_FINAL { return New(NULL); }

  SetVal* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SetVal& from);
  void MergeFrom(const SetVal& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SetVal* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // string val = 2;
  void clear_val();
  static const int kValFieldNumber = 2;
  const ::std::string& val() const;
  void set_val(const ::std::string& value);
  #if LANG_CXX11
  void set_val(::std::string&& value);
  #endif
  void set_val(const char* value);
  void set_val(const char* value, size_t size);
  ::std::string* mutable_val();
  ::std::string* release_val();
  void set_allocated_val(::std::string* val);

  // @@protoc_insertion_point(class_scope:message.SetVal)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr val_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultsSetValImpl();
};
// -------------------------------------------------------------------

class Message : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:message.Message) */ {
 public:
  Message();
  virtual ~Message();

  Message(const Message& from);

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Message(Message&& from) noexcept
    : Message() {
    *this = ::std::move(from);
  }

  inline Message& operator=(Message&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Message& default_instance();

  enum MsgCase {
    kJoinMeMsg = 2,
    kJoinMsg = 3,
    kGetValMsg = 4,
    kSetValMsg = 5,
    kRoutingUpdate = 6,
    kAllStateUpdate = 7,
    MSG_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Message* internal_default_instance() {
    return reinterpret_cast<const Message*>(
               &_Message_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(Message* other);
  friend void swap(Message& a, Message& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Message* New() const PROTOBUF_FINAL { return New(NULL); }

  Message* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Message& from);
  void MergeFrom(const Message& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Message* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // .message.JoinMe joinMeMsg = 2;
  bool has_joinmemsg() const;
  void clear_joinmemsg();
  static const int kJoinMeMsgFieldNumber = 2;
  const ::message::JoinMe& joinmemsg() const;
  ::message::JoinMe* release_joinmemsg();
  ::message::JoinMe* mutable_joinmemsg();
  void set_allocated_joinmemsg(::message::JoinMe* joinmemsg);

  // .message.Join joinMsg = 3;
  bool has_joinmsg() const;
  void clear_joinmsg();
  static const int kJoinMsgFieldNumber = 3;
  const ::message::Join& joinmsg() const;
  ::message::Join* release_joinmsg();
  ::message::Join* mutable_joinmsg();
  void set_allocated_joinmsg(::message::Join* joinmsg);

  // .message.GetVal getValMsg = 4;
  bool has_getvalmsg() const;
  void clear_getvalmsg();
  static const int kGetValMsgFieldNumber = 4;
  const ::message::GetVal& getvalmsg() const;
  ::message::GetVal* release_getvalmsg();
  ::message::GetVal* mutable_getvalmsg();
  void set_allocated_getvalmsg(::message::GetVal* getvalmsg);

  // .message.SetVal setValMsg = 5;
  bool has_setvalmsg() const;
  void clear_setvalmsg();
  static const int kSetValMsgFieldNumber = 5;
  const ::message::SetVal& setvalmsg() const;
  ::message::SetVal* release_setvalmsg();
  ::message::SetVal* mutable_setvalmsg();
  void set_allocated_setvalmsg(::message::SetVal* setvalmsg);

  // .message.RoutingUpdate routingUpdate = 6;
  bool has_routingupdate() const;
  void clear_routingupdate();
  static const int kRoutingUpdateFieldNumber = 6;
  const ::message::RoutingUpdate& routingupdate() const;
  ::message::RoutingUpdate* release_routingupdate();
  ::message::RoutingUpdate* mutable_routingupdate();
  void set_allocated_routingupdate(::message::RoutingUpdate* routingupdate);

  // .message.AllStateUpdate allStateUpdate = 7;
  bool has_allstateupdate() const;
  void clear_allstateupdate();
  static const int kAllStateUpdateFieldNumber = 7;
  const ::message::AllStateUpdate& allstateupdate() const;
  ::message::AllStateUpdate* release_allstateupdate();
  ::message::AllStateUpdate* mutable_allstateupdate();
  void set_allocated_allstateupdate(::message::AllStateUpdate* allstateupdate);

  MsgCase msg_case() const;
  // @@protoc_insertion_point(class_scope:message.Message)
 private:
  void set_has_joinmemsg();
  void set_has_joinmsg();
  void set_has_getvalmsg();
  void set_has_setvalmsg();
  void set_has_routingupdate();
  void set_has_allstateupdate();

  inline bool has_msg() const;
  void clear_msg();
  inline void clear_has_msg();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  union MsgUnion {
    MsgUnion() {}
    ::message::JoinMe* joinmemsg_;
    ::message::Join* joinmsg_;
    ::message::GetVal* getvalmsg_;
    ::message::SetVal* setvalmsg_;
    ::message::RoutingUpdate* routingupdate_;
    ::message::AllStateUpdate* allstateupdate_;
  } msg_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultsMessageImpl();
};
// -------------------------------------------------------------------

class Response : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:message.Response) */ {
 public:
  Response();
  virtual ~Response();

  Response(const Response& from);

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Response(Response&& from) noexcept
    : Response() {
    *this = ::std::move(from);
  }

  inline Response& operator=(Response&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Response& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Response* internal_default_instance() {
    return reinterpret_cast<const Response*>(
               &_Response_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(Response* other);
  friend void swap(Response& a, Response& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Response* New() const PROTOBUF_FINAL { return New(NULL); }

  Response* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Response& from);
  void MergeFrom(const Response& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Response* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string status = 1;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  const ::std::string& status() const;
  void set_status(const ::std::string& value);
  #if LANG_CXX11
  void set_status(::std::string&& value);
  #endif
  void set_status(const char* value);
  void set_status(const char* value, size_t size);
  ::std::string* mutable_status();
  ::std::string* release_status();
  void set_allocated_status(::std::string* status);

  // @@protoc_insertion_point(class_scope:message.Response)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr status_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultsResponseImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// JoinMe

// string nodeID = 1;
inline void JoinMe::clear_nodeid() {
  nodeid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& JoinMe::nodeid() const {
  // @@protoc_insertion_point(field_get:message.JoinMe.nodeID)
  return nodeid_.GetNoArena();
}
inline void JoinMe::set_nodeid(const ::std::string& value) {
  
  nodeid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:message.JoinMe.nodeID)
}
#if LANG_CXX11
inline void JoinMe::set_nodeid(::std::string&& value) {
  
  nodeid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:message.JoinMe.nodeID)
}
#endif
inline void JoinMe::set_nodeid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  nodeid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:message.JoinMe.nodeID)
}
inline void JoinMe::set_nodeid(const char* value, size_t size) {
  
  nodeid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:message.JoinMe.nodeID)
}
inline ::std::string* JoinMe::mutable_nodeid() {
  
  // @@protoc_insertion_point(field_mutable:message.JoinMe.nodeID)
  return nodeid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* JoinMe::release_nodeid() {
  // @@protoc_insertion_point(field_release:message.JoinMe.nodeID)
  
  return nodeid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void JoinMe::set_allocated_nodeid(::std::string* nodeid) {
  if (nodeid != NULL) {
    
  } else {
    
  }
  nodeid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nodeid);
  // @@protoc_insertion_point(field_set_allocated:message.JoinMe.nodeID)
}

// string IP = 2;
inline void JoinMe::clear_ip() {
  ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& JoinMe::ip() const {
  // @@protoc_insertion_point(field_get:message.JoinMe.IP)
  return ip_.GetNoArena();
}
inline void JoinMe::set_ip(const ::std::string& value) {
  
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:message.JoinMe.IP)
}
#if LANG_CXX11
inline void JoinMe::set_ip(::std::string&& value) {
  
  ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:message.JoinMe.IP)
}
#endif
inline void JoinMe::set_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:message.JoinMe.IP)
}
inline void JoinMe::set_ip(const char* value, size_t size) {
  
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:message.JoinMe.IP)
}
inline ::std::string* JoinMe::mutable_ip() {
  
  // @@protoc_insertion_point(field_mutable:message.JoinMe.IP)
  return ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* JoinMe::release_ip() {
  // @@protoc_insertion_point(field_release:message.JoinMe.IP)
  
  return ip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void JoinMe::set_allocated_ip(::std::string* ip) {
  if (ip != NULL) {
    
  } else {
    
  }
  ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip);
  // @@protoc_insertion_point(field_set_allocated:message.JoinMe.IP)
}

// string port = 3;
inline void JoinMe::clear_port() {
  port_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& JoinMe::port() const {
  // @@protoc_insertion_point(field_get:message.JoinMe.port)
  return port_.GetNoArena();
}
inline void JoinMe::set_port(const ::std::string& value) {
  
  port_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:message.JoinMe.port)
}
#if LANG_CXX11
inline void JoinMe::set_port(::std::string&& value) {
  
  port_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:message.JoinMe.port)
}
#endif
inline void JoinMe::set_port(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  port_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:message.JoinMe.port)
}
inline void JoinMe::set_port(const char* value, size_t size) {
  
  port_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:message.JoinMe.port)
}
inline ::std::string* JoinMe::mutable_port() {
  
  // @@protoc_insertion_point(field_mutable:message.JoinMe.port)
  return port_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* JoinMe::release_port() {
  // @@protoc_insertion_point(field_release:message.JoinMe.port)
  
  return port_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void JoinMe::set_allocated_port(::std::string* port) {
  if (port != NULL) {
    
  } else {
    
  }
  port_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), port);
  // @@protoc_insertion_point(field_set_allocated:message.JoinMe.port)
}

// -------------------------------------------------------------------

// Join

// string nodeID = 1;
inline void Join::clear_nodeid() {
  nodeid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Join::nodeid() const {
  // @@protoc_insertion_point(field_get:message.Join.nodeID)
  return nodeid_.GetNoArena();
}
inline void Join::set_nodeid(const ::std::string& value) {
  
  nodeid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:message.Join.nodeID)
}
#if LANG_CXX11
inline void Join::set_nodeid(::std::string&& value) {
  
  nodeid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:message.Join.nodeID)
}
#endif
inline void Join::set_nodeid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  nodeid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:message.Join.nodeID)
}
inline void Join::set_nodeid(const char* value, size_t size) {
  
  nodeid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:message.Join.nodeID)
}
inline ::std::string* Join::mutable_nodeid() {
  
  // @@protoc_insertion_point(field_mutable:message.Join.nodeID)
  return nodeid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Join::release_nodeid() {
  // @@protoc_insertion_point(field_release:message.Join.nodeID)
  
  return nodeid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Join::set_allocated_nodeid(::std::string* nodeid) {
  if (nodeid != NULL) {
    
  } else {
    
  }
  nodeid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nodeid);
  // @@protoc_insertion_point(field_set_allocated:message.Join.nodeID)
}

// string IP = 2;
inline void Join::clear_ip() {
  ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Join::ip() const {
  // @@protoc_insertion_point(field_get:message.Join.IP)
  return ip_.GetNoArena();
}
inline void Join::set_ip(const ::std::string& value) {
  
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:message.Join.IP)
}
#if LANG_CXX11
inline void Join::set_ip(::std::string&& value) {
  
  ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:message.Join.IP)
}
#endif
inline void Join::set_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:message.Join.IP)
}
inline void Join::set_ip(const char* value, size_t size) {
  
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:message.Join.IP)
}
inline ::std::string* Join::mutable_ip() {
  
  // @@protoc_insertion_point(field_mutable:message.Join.IP)
  return ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Join::release_ip() {
  // @@protoc_insertion_point(field_release:message.Join.IP)
  
  return ip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Join::set_allocated_ip(::std::string* ip) {
  if (ip != NULL) {
    
  } else {
    
  }
  ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip);
  // @@protoc_insertion_point(field_set_allocated:message.Join.IP)
}

// string port = 3;
inline void Join::clear_port() {
  port_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Join::port() const {
  // @@protoc_insertion_point(field_get:message.Join.port)
  return port_.GetNoArena();
}
inline void Join::set_port(const ::std::string& value) {
  
  port_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:message.Join.port)
}
#if LANG_CXX11
inline void Join::set_port(::std::string&& value) {
  
  port_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:message.Join.port)
}
#endif
inline void Join::set_port(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  port_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:message.Join.port)
}
inline void Join::set_port(const char* value, size_t size) {
  
  port_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:message.Join.port)
}
inline ::std::string* Join::mutable_port() {
  
  // @@protoc_insertion_point(field_mutable:message.Join.port)
  return port_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Join::release_port() {
  // @@protoc_insertion_point(field_release:message.Join.port)
  
  return port_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Join::set_allocated_port(::std::string* port) {
  if (port != NULL) {
    
  } else {
    
  }
  port_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), port);
  // @@protoc_insertion_point(field_set_allocated:message.Join.port)
}

// int32 row_index = 4;
inline void Join::clear_row_index() {
  row_index_ = 0;
}
inline ::google::protobuf::int32 Join::row_index() const {
  // @@protoc_insertion_point(field_get:message.Join.row_index)
  return row_index_;
}
inline void Join::set_row_index(::google::protobuf::int32 value) {
  
  row_index_ = value;
  // @@protoc_insertion_point(field_set:message.Join.row_index)
}

// -------------------------------------------------------------------

// Node

// string nodeID = 1;
inline void Node::clear_nodeid() {
  nodeid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Node::nodeid() const {
  // @@protoc_insertion_point(field_get:message.Node.nodeID)
  return nodeid_.GetNoArena();
}
inline void Node::set_nodeid(const ::std::string& value) {
  
  nodeid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:message.Node.nodeID)
}
#if LANG_CXX11
inline void Node::set_nodeid(::std::string&& value) {
  
  nodeid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:message.Node.nodeID)
}
#endif
inline void Node::set_nodeid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  nodeid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:message.Node.nodeID)
}
inline void Node::set_nodeid(const char* value, size_t size) {
  
  nodeid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:message.Node.nodeID)
}
inline ::std::string* Node::mutable_nodeid() {
  
  // @@protoc_insertion_point(field_mutable:message.Node.nodeID)
  return nodeid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Node::release_nodeid() {
  // @@protoc_insertion_point(field_release:message.Node.nodeID)
  
  return nodeid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node::set_allocated_nodeid(::std::string* nodeid) {
  if (nodeid != NULL) {
    
  } else {
    
  }
  nodeid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nodeid);
  // @@protoc_insertion_point(field_set_allocated:message.Node.nodeID)
}

// string IP = 2;
inline void Node::clear_ip() {
  ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Node::ip() const {
  // @@protoc_insertion_point(field_get:message.Node.IP)
  return ip_.GetNoArena();
}
inline void Node::set_ip(const ::std::string& value) {
  
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:message.Node.IP)
}
#if LANG_CXX11
inline void Node::set_ip(::std::string&& value) {
  
  ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:message.Node.IP)
}
#endif
inline void Node::set_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:message.Node.IP)
}
inline void Node::set_ip(const char* value, size_t size) {
  
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:message.Node.IP)
}
inline ::std::string* Node::mutable_ip() {
  
  // @@protoc_insertion_point(field_mutable:message.Node.IP)
  return ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Node::release_ip() {
  // @@protoc_insertion_point(field_release:message.Node.IP)
  
  return ip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node::set_allocated_ip(::std::string* ip) {
  if (ip != NULL) {
    
  } else {
    
  }
  ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip);
  // @@protoc_insertion_point(field_set_allocated:message.Node.IP)
}

// string port = 3;
inline void Node::clear_port() {
  port_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Node::port() const {
  // @@protoc_insertion_point(field_get:message.Node.port)
  return port_.GetNoArena();
}
inline void Node::set_port(const ::std::string& value) {
  
  port_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:message.Node.port)
}
#if LANG_CXX11
inline void Node::set_port(::std::string&& value) {
  
  port_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:message.Node.port)
}
#endif
inline void Node::set_port(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  port_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:message.Node.port)
}
inline void Node::set_port(const char* value, size_t size) {
  
  port_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:message.Node.port)
}
inline ::std::string* Node::mutable_port() {
  
  // @@protoc_insertion_point(field_mutable:message.Node.port)
  return port_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Node::release_port() {
  // @@protoc_insertion_point(field_release:message.Node.port)
  
  return port_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node::set_allocated_port(::std::string* port) {
  if (port != NULL) {
    
  } else {
    
  }
  port_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), port);
  // @@protoc_insertion_point(field_set_allocated:message.Node.port)
}

// -------------------------------------------------------------------

// List

// repeated .message.Node node = 1;
inline int List::node_size() const {
  return node_.size();
}
inline void List::clear_node() {
  node_.Clear();
}
inline const ::message::Node& List::node(int index) const {
  // @@protoc_insertion_point(field_get:message.List.node)
  return node_.Get(index);
}
inline ::message::Node* List::mutable_node(int index) {
  // @@protoc_insertion_point(field_mutable:message.List.node)
  return node_.Mutable(index);
}
inline ::message::Node* List::add_node() {
  // @@protoc_insertion_point(field_add:message.List.node)
  return node_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::message::Node >*
List::mutable_node() {
  // @@protoc_insertion_point(field_mutable_list:message.List.node)
  return &node_;
}
inline const ::google::protobuf::RepeatedPtrField< ::message::Node >&
List::node() const {
  // @@protoc_insertion_point(field_list:message.List.node)
  return node_;
}

// -------------------------------------------------------------------

// RoutingUpdate_RoutingEntry

// int32 index = 1;
inline void RoutingUpdate_RoutingEntry::clear_index() {
  index_ = 0;
}
inline ::google::protobuf::int32 RoutingUpdate_RoutingEntry::index() const {
  // @@protoc_insertion_point(field_get:message.RoutingUpdate.RoutingEntry.index)
  return index_;
}
inline void RoutingUpdate_RoutingEntry::set_index(::google::protobuf::int32 value) {
  
  index_ = value;
  // @@protoc_insertion_point(field_set:message.RoutingUpdate.RoutingEntry.index)
}

// .message.List nodeList = 2;
inline bool RoutingUpdate_RoutingEntry::has_nodelist() const {
  return this != internal_default_instance() && nodelist_ != NULL;
}
inline void RoutingUpdate_RoutingEntry::clear_nodelist() {
  if (GetArenaNoVirtual() == NULL && nodelist_ != NULL) {
    delete nodelist_;
  }
  nodelist_ = NULL;
}
inline const ::message::List& RoutingUpdate_RoutingEntry::nodelist() const {
  const ::message::List* p = nodelist_;
  // @@protoc_insertion_point(field_get:message.RoutingUpdate.RoutingEntry.nodeList)
  return p != NULL ? *p : *reinterpret_cast<const ::message::List*>(
      &::message::_List_default_instance_);
}
inline ::message::List* RoutingUpdate_RoutingEntry::release_nodelist() {
  // @@protoc_insertion_point(field_release:message.RoutingUpdate.RoutingEntry.nodeList)
  
  ::message::List* temp = nodelist_;
  nodelist_ = NULL;
  return temp;
}
inline ::message::List* RoutingUpdate_RoutingEntry::mutable_nodelist() {
  
  if (nodelist_ == NULL) {
    nodelist_ = new ::message::List;
  }
  // @@protoc_insertion_point(field_mutable:message.RoutingUpdate.RoutingEntry.nodeList)
  return nodelist_;
}
inline void RoutingUpdate_RoutingEntry::set_allocated_nodelist(::message::List* nodelist) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete nodelist_;
  }
  if (nodelist) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      nodelist = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, nodelist, submessage_arena);
    }
    
  } else {
    
  }
  nodelist_ = nodelist;
  // @@protoc_insertion_point(field_set_allocated:message.RoutingUpdate.RoutingEntry.nodeList)
}

// -------------------------------------------------------------------

// RoutingUpdate

// bool buddy = 1;
inline void RoutingUpdate::clear_buddy() {
  buddy_ = false;
}
inline bool RoutingUpdate::buddy() const {
  // @@protoc_insertion_point(field_get:message.RoutingUpdate.buddy)
  return buddy_;
}
inline void RoutingUpdate::set_buddy(bool value) {
  
  buddy_ = value;
  // @@protoc_insertion_point(field_set:message.RoutingUpdate.buddy)
}

// bool terminal = 2;
inline void RoutingUpdate::clear_terminal() {
  terminal_ = false;
}
inline bool RoutingUpdate::terminal() const {
  // @@protoc_insertion_point(field_get:message.RoutingUpdate.terminal)
  return terminal_;
}
inline void RoutingUpdate::set_terminal(bool value) {
  
  terminal_ = value;
  // @@protoc_insertion_point(field_set:message.RoutingUpdate.terminal)
}

// .message.List leaf = 3;
inline bool RoutingUpdate::has_leaf() const {
  return this != internal_default_instance() && leaf_ != NULL;
}
inline void RoutingUpdate::clear_leaf() {
  if (GetArenaNoVirtual() == NULL && leaf_ != NULL) {
    delete leaf_;
  }
  leaf_ = NULL;
}
inline const ::message::List& RoutingUpdate::leaf() const {
  const ::message::List* p = leaf_;
  // @@protoc_insertion_point(field_get:message.RoutingUpdate.leaf)
  return p != NULL ? *p : *reinterpret_cast<const ::message::List*>(
      &::message::_List_default_instance_);
}
inline ::message::List* RoutingUpdate::release_leaf() {
  // @@protoc_insertion_point(field_release:message.RoutingUpdate.leaf)
  
  ::message::List* temp = leaf_;
  leaf_ = NULL;
  return temp;
}
inline ::message::List* RoutingUpdate::mutable_leaf() {
  
  if (leaf_ == NULL) {
    leaf_ = new ::message::List;
  }
  // @@protoc_insertion_point(field_mutable:message.RoutingUpdate.leaf)
  return leaf_;
}
inline void RoutingUpdate::set_allocated_leaf(::message::List* leaf) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete leaf_;
  }
  if (leaf) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      leaf = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, leaf, submessage_arena);
    }
    
  } else {
    
  }
  leaf_ = leaf;
  // @@protoc_insertion_point(field_set_allocated:message.RoutingUpdate.leaf)
}

// .message.List neighbours = 4;
inline bool RoutingUpdate::has_neighbours() const {
  return this != internal_default_instance() && neighbours_ != NULL;
}
inline void RoutingUpdate::clear_neighbours() {
  if (GetArenaNoVirtual() == NULL && neighbours_ != NULL) {
    delete neighbours_;
  }
  neighbours_ = NULL;
}
inline const ::message::List& RoutingUpdate::neighbours() const {
  const ::message::List* p = neighbours_;
  // @@protoc_insertion_point(field_get:message.RoutingUpdate.neighbours)
  return p != NULL ? *p : *reinterpret_cast<const ::message::List*>(
      &::message::_List_default_instance_);
}
inline ::message::List* RoutingUpdate::release_neighbours() {
  // @@protoc_insertion_point(field_release:message.RoutingUpdate.neighbours)
  
  ::message::List* temp = neighbours_;
  neighbours_ = NULL;
  return temp;
}
inline ::message::List* RoutingUpdate::mutable_neighbours() {
  
  if (neighbours_ == NULL) {
    neighbours_ = new ::message::List;
  }
  // @@protoc_insertion_point(field_mutable:message.RoutingUpdate.neighbours)
  return neighbours_;
}
inline void RoutingUpdate::set_allocated_neighbours(::message::List* neighbours) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete neighbours_;
  }
  if (neighbours) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      neighbours = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, neighbours, submessage_arena);
    }
    
  } else {
    
  }
  neighbours_ = neighbours;
  // @@protoc_insertion_point(field_set_allocated:message.RoutingUpdate.neighbours)
}

// repeated .message.RoutingUpdate.RoutingEntry routingEntires = 5;
inline int RoutingUpdate::routingentires_size() const {
  return routingentires_.size();
}
inline void RoutingUpdate::clear_routingentires() {
  routingentires_.Clear();
}
inline const ::message::RoutingUpdate_RoutingEntry& RoutingUpdate::routingentires(int index) const {
  // @@protoc_insertion_point(field_get:message.RoutingUpdate.routingEntires)
  return routingentires_.Get(index);
}
inline ::message::RoutingUpdate_RoutingEntry* RoutingUpdate::mutable_routingentires(int index) {
  // @@protoc_insertion_point(field_mutable:message.RoutingUpdate.routingEntires)
  return routingentires_.Mutable(index);
}
inline ::message::RoutingUpdate_RoutingEntry* RoutingUpdate::add_routingentires() {
  // @@protoc_insertion_point(field_add:message.RoutingUpdate.routingEntires)
  return routingentires_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::message::RoutingUpdate_RoutingEntry >*
RoutingUpdate::mutable_routingentires() {
  // @@protoc_insertion_point(field_mutable_list:message.RoutingUpdate.routingEntires)
  return &routingentires_;
}
inline const ::google::protobuf::RepeatedPtrField< ::message::RoutingUpdate_RoutingEntry >&
RoutingUpdate::routingentires() const {
  // @@protoc_insertion_point(field_list:message.RoutingUpdate.routingEntires)
  return routingentires_;
}

// -------------------------------------------------------------------

// AllStateUpdate

// repeated .message.List leaf = 1;
inline int AllStateUpdate::leaf_size() const {
  return leaf_.size();
}
inline void AllStateUpdate::clear_leaf() {
  leaf_.Clear();
}
inline const ::message::List& AllStateUpdate::leaf(int index) const {
  // @@protoc_insertion_point(field_get:message.AllStateUpdate.leaf)
  return leaf_.Get(index);
}
inline ::message::List* AllStateUpdate::mutable_leaf(int index) {
  // @@protoc_insertion_point(field_mutable:message.AllStateUpdate.leaf)
  return leaf_.Mutable(index);
}
inline ::message::List* AllStateUpdate::add_leaf() {
  // @@protoc_insertion_point(field_add:message.AllStateUpdate.leaf)
  return leaf_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::message::List >*
AllStateUpdate::mutable_leaf() {
  // @@protoc_insertion_point(field_mutable_list:message.AllStateUpdate.leaf)
  return &leaf_;
}
inline const ::google::protobuf::RepeatedPtrField< ::message::List >&
AllStateUpdate::leaf() const {
  // @@protoc_insertion_point(field_list:message.AllStateUpdate.leaf)
  return leaf_;
}

// repeated .message.List routingTable = 2;
inline int AllStateUpdate::routingtable_size() const {
  return routingtable_.size();
}
inline void AllStateUpdate::clear_routingtable() {
  routingtable_.Clear();
}
inline const ::message::List& AllStateUpdate::routingtable(int index) const {
  // @@protoc_insertion_point(field_get:message.AllStateUpdate.routingTable)
  return routingtable_.Get(index);
}
inline ::message::List* AllStateUpdate::mutable_routingtable(int index) {
  // @@protoc_insertion_point(field_mutable:message.AllStateUpdate.routingTable)
  return routingtable_.Mutable(index);
}
inline ::message::List* AllStateUpdate::add_routingtable() {
  // @@protoc_insertion_point(field_add:message.AllStateUpdate.routingTable)
  return routingtable_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::message::List >*
AllStateUpdate::mutable_routingtable() {
  // @@protoc_insertion_point(field_mutable_list:message.AllStateUpdate.routingTable)
  return &routingtable_;
}
inline const ::google::protobuf::RepeatedPtrField< ::message::List >&
AllStateUpdate::routingtable() const {
  // @@protoc_insertion_point(field_list:message.AllStateUpdate.routingTable)
  return routingtable_;
}

// repeated .message.List neighbours = 3;
inline int AllStateUpdate::neighbours_size() const {
  return neighbours_.size();
}
inline void AllStateUpdate::clear_neighbours() {
  neighbours_.Clear();
}
inline const ::message::List& AllStateUpdate::neighbours(int index) const {
  // @@protoc_insertion_point(field_get:message.AllStateUpdate.neighbours)
  return neighbours_.Get(index);
}
inline ::message::List* AllStateUpdate::mutable_neighbours(int index) {
  // @@protoc_insertion_point(field_mutable:message.AllStateUpdate.neighbours)
  return neighbours_.Mutable(index);
}
inline ::message::List* AllStateUpdate::add_neighbours() {
  // @@protoc_insertion_point(field_add:message.AllStateUpdate.neighbours)
  return neighbours_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::message::List >*
AllStateUpdate::mutable_neighbours() {
  // @@protoc_insertion_point(field_mutable_list:message.AllStateUpdate.neighbours)
  return &neighbours_;
}
inline const ::google::protobuf::RepeatedPtrField< ::message::List >&
AllStateUpdate::neighbours() const {
  // @@protoc_insertion_point(field_list:message.AllStateUpdate.neighbours)
  return neighbours_;
}

// -------------------------------------------------------------------

// GetVal

// string key = 1;
inline void GetVal::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetVal::key() const {
  // @@protoc_insertion_point(field_get:message.GetVal.key)
  return key_.GetNoArena();
}
inline void GetVal::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:message.GetVal.key)
}
#if LANG_CXX11
inline void GetVal::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:message.GetVal.key)
}
#endif
inline void GetVal::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:message.GetVal.key)
}
inline void GetVal::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:message.GetVal.key)
}
inline ::std::string* GetVal::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:message.GetVal.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetVal::release_key() {
  // @@protoc_insertion_point(field_release:message.GetVal.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetVal::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:message.GetVal.key)
}

// .message.Node node = 2;
inline bool GetVal::has_node() const {
  return this != internal_default_instance() && node_ != NULL;
}
inline void GetVal::clear_node() {
  if (GetArenaNoVirtual() == NULL && node_ != NULL) {
    delete node_;
  }
  node_ = NULL;
}
inline const ::message::Node& GetVal::node() const {
  const ::message::Node* p = node_;
  // @@protoc_insertion_point(field_get:message.GetVal.node)
  return p != NULL ? *p : *reinterpret_cast<const ::message::Node*>(
      &::message::_Node_default_instance_);
}
inline ::message::Node* GetVal::release_node() {
  // @@protoc_insertion_point(field_release:message.GetVal.node)
  
  ::message::Node* temp = node_;
  node_ = NULL;
  return temp;
}
inline ::message::Node* GetVal::mutable_node() {
  
  if (node_ == NULL) {
    node_ = new ::message::Node;
  }
  // @@protoc_insertion_point(field_mutable:message.GetVal.node)
  return node_;
}
inline void GetVal::set_allocated_node(::message::Node* node) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete node_;
  }
  if (node) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      node = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, node, submessage_arena);
    }
    
  } else {
    
  }
  node_ = node;
  // @@protoc_insertion_point(field_set_allocated:message.GetVal.node)
}

// -------------------------------------------------------------------

// SetVal

// string key = 1;
inline void SetVal::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SetVal::key() const {
  // @@protoc_insertion_point(field_get:message.SetVal.key)
  return key_.GetNoArena();
}
inline void SetVal::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:message.SetVal.key)
}
#if LANG_CXX11
inline void SetVal::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:message.SetVal.key)
}
#endif
inline void SetVal::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:message.SetVal.key)
}
inline void SetVal::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:message.SetVal.key)
}
inline ::std::string* SetVal::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:message.SetVal.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SetVal::release_key() {
  // @@protoc_insertion_point(field_release:message.SetVal.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SetVal::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:message.SetVal.key)
}

// string val = 2;
inline void SetVal::clear_val() {
  val_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SetVal::val() const {
  // @@protoc_insertion_point(field_get:message.SetVal.val)
  return val_.GetNoArena();
}
inline void SetVal::set_val(const ::std::string& value) {
  
  val_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:message.SetVal.val)
}
#if LANG_CXX11
inline void SetVal::set_val(::std::string&& value) {
  
  val_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:message.SetVal.val)
}
#endif
inline void SetVal::set_val(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  val_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:message.SetVal.val)
}
inline void SetVal::set_val(const char* value, size_t size) {
  
  val_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:message.SetVal.val)
}
inline ::std::string* SetVal::mutable_val() {
  
  // @@protoc_insertion_point(field_mutable:message.SetVal.val)
  return val_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SetVal::release_val() {
  // @@protoc_insertion_point(field_release:message.SetVal.val)
  
  return val_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SetVal::set_allocated_val(::std::string* val) {
  if (val != NULL) {
    
  } else {
    
  }
  val_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), val);
  // @@protoc_insertion_point(field_set_allocated:message.SetVal.val)
}

// -------------------------------------------------------------------

// Message

// string type = 1;
inline void Message::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Message::type() const {
  // @@protoc_insertion_point(field_get:message.Message.type)
  return type_.GetNoArena();
}
inline void Message::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:message.Message.type)
}
#if LANG_CXX11
inline void Message::set_type(::std::string&& value) {
  
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:message.Message.type)
}
#endif
inline void Message::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:message.Message.type)
}
inline void Message::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:message.Message.type)
}
inline ::std::string* Message::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:message.Message.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Message::release_type() {
  // @@protoc_insertion_point(field_release:message.Message.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Message::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:message.Message.type)
}

// .message.JoinMe joinMeMsg = 2;
inline bool Message::has_joinmemsg() const {
  return msg_case() == kJoinMeMsg;
}
inline void Message::set_has_joinmemsg() {
  _oneof_case_[0] = kJoinMeMsg;
}
inline void Message::clear_joinmemsg() {
  if (has_joinmemsg()) {
    delete msg_.joinmemsg_;
    clear_has_msg();
  }
}
inline ::message::JoinMe* Message::release_joinmemsg() {
  // @@protoc_insertion_point(field_release:message.Message.joinMeMsg)
  if (has_joinmemsg()) {
    clear_has_msg();
      ::message::JoinMe* temp = msg_.joinmemsg_;
    msg_.joinmemsg_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::message::JoinMe& Message::joinmemsg() const {
  // @@protoc_insertion_point(field_get:message.Message.joinMeMsg)
  return has_joinmemsg()
      ? *msg_.joinmemsg_
      : *reinterpret_cast< ::message::JoinMe*>(&::message::_JoinMe_default_instance_);
}
inline ::message::JoinMe* Message::mutable_joinmemsg() {
  if (!has_joinmemsg()) {
    clear_msg();
    set_has_joinmemsg();
    msg_.joinmemsg_ = new ::message::JoinMe;
  }
  // @@protoc_insertion_point(field_mutable:message.Message.joinMeMsg)
  return msg_.joinmemsg_;
}

// .message.Join joinMsg = 3;
inline bool Message::has_joinmsg() const {
  return msg_case() == kJoinMsg;
}
inline void Message::set_has_joinmsg() {
  _oneof_case_[0] = kJoinMsg;
}
inline void Message::clear_joinmsg() {
  if (has_joinmsg()) {
    delete msg_.joinmsg_;
    clear_has_msg();
  }
}
inline ::message::Join* Message::release_joinmsg() {
  // @@protoc_insertion_point(field_release:message.Message.joinMsg)
  if (has_joinmsg()) {
    clear_has_msg();
      ::message::Join* temp = msg_.joinmsg_;
    msg_.joinmsg_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::message::Join& Message::joinmsg() const {
  // @@protoc_insertion_point(field_get:message.Message.joinMsg)
  return has_joinmsg()
      ? *msg_.joinmsg_
      : *reinterpret_cast< ::message::Join*>(&::message::_Join_default_instance_);
}
inline ::message::Join* Message::mutable_joinmsg() {
  if (!has_joinmsg()) {
    clear_msg();
    set_has_joinmsg();
    msg_.joinmsg_ = new ::message::Join;
  }
  // @@protoc_insertion_point(field_mutable:message.Message.joinMsg)
  return msg_.joinmsg_;
}

// .message.GetVal getValMsg = 4;
inline bool Message::has_getvalmsg() const {
  return msg_case() == kGetValMsg;
}
inline void Message::set_has_getvalmsg() {
  _oneof_case_[0] = kGetValMsg;
}
inline void Message::clear_getvalmsg() {
  if (has_getvalmsg()) {
    delete msg_.getvalmsg_;
    clear_has_msg();
  }
}
inline ::message::GetVal* Message::release_getvalmsg() {
  // @@protoc_insertion_point(field_release:message.Message.getValMsg)
  if (has_getvalmsg()) {
    clear_has_msg();
      ::message::GetVal* temp = msg_.getvalmsg_;
    msg_.getvalmsg_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::message::GetVal& Message::getvalmsg() const {
  // @@protoc_insertion_point(field_get:message.Message.getValMsg)
  return has_getvalmsg()
      ? *msg_.getvalmsg_
      : *reinterpret_cast< ::message::GetVal*>(&::message::_GetVal_default_instance_);
}
inline ::message::GetVal* Message::mutable_getvalmsg() {
  if (!has_getvalmsg()) {
    clear_msg();
    set_has_getvalmsg();
    msg_.getvalmsg_ = new ::message::GetVal;
  }
  // @@protoc_insertion_point(field_mutable:message.Message.getValMsg)
  return msg_.getvalmsg_;
}

// .message.SetVal setValMsg = 5;
inline bool Message::has_setvalmsg() const {
  return msg_case() == kSetValMsg;
}
inline void Message::set_has_setvalmsg() {
  _oneof_case_[0] = kSetValMsg;
}
inline void Message::clear_setvalmsg() {
  if (has_setvalmsg()) {
    delete msg_.setvalmsg_;
    clear_has_msg();
  }
}
inline ::message::SetVal* Message::release_setvalmsg() {
  // @@protoc_insertion_point(field_release:message.Message.setValMsg)
  if (has_setvalmsg()) {
    clear_has_msg();
      ::message::SetVal* temp = msg_.setvalmsg_;
    msg_.setvalmsg_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::message::SetVal& Message::setvalmsg() const {
  // @@protoc_insertion_point(field_get:message.Message.setValMsg)
  return has_setvalmsg()
      ? *msg_.setvalmsg_
      : *reinterpret_cast< ::message::SetVal*>(&::message::_SetVal_default_instance_);
}
inline ::message::SetVal* Message::mutable_setvalmsg() {
  if (!has_setvalmsg()) {
    clear_msg();
    set_has_setvalmsg();
    msg_.setvalmsg_ = new ::message::SetVal;
  }
  // @@protoc_insertion_point(field_mutable:message.Message.setValMsg)
  return msg_.setvalmsg_;
}

// .message.RoutingUpdate routingUpdate = 6;
inline bool Message::has_routingupdate() const {
  return msg_case() == kRoutingUpdate;
}
inline void Message::set_has_routingupdate() {
  _oneof_case_[0] = kRoutingUpdate;
}
inline void Message::clear_routingupdate() {
  if (has_routingupdate()) {
    delete msg_.routingupdate_;
    clear_has_msg();
  }
}
inline ::message::RoutingUpdate* Message::release_routingupdate() {
  // @@protoc_insertion_point(field_release:message.Message.routingUpdate)
  if (has_routingupdate()) {
    clear_has_msg();
      ::message::RoutingUpdate* temp = msg_.routingupdate_;
    msg_.routingupdate_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::message::RoutingUpdate& Message::routingupdate() const {
  // @@protoc_insertion_point(field_get:message.Message.routingUpdate)
  return has_routingupdate()
      ? *msg_.routingupdate_
      : *reinterpret_cast< ::message::RoutingUpdate*>(&::message::_RoutingUpdate_default_instance_);
}
inline ::message::RoutingUpdate* Message::mutable_routingupdate() {
  if (!has_routingupdate()) {
    clear_msg();
    set_has_routingupdate();
    msg_.routingupdate_ = new ::message::RoutingUpdate;
  }
  // @@protoc_insertion_point(field_mutable:message.Message.routingUpdate)
  return msg_.routingupdate_;
}

// .message.AllStateUpdate allStateUpdate = 7;
inline bool Message::has_allstateupdate() const {
  return msg_case() == kAllStateUpdate;
}
inline void Message::set_has_allstateupdate() {
  _oneof_case_[0] = kAllStateUpdate;
}
inline void Message::clear_allstateupdate() {
  if (has_allstateupdate()) {
    delete msg_.allstateupdate_;
    clear_has_msg();
  }
}
inline ::message::AllStateUpdate* Message::release_allstateupdate() {
  // @@protoc_insertion_point(field_release:message.Message.allStateUpdate)
  if (has_allstateupdate()) {
    clear_has_msg();
      ::message::AllStateUpdate* temp = msg_.allstateupdate_;
    msg_.allstateupdate_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::message::AllStateUpdate& Message::allstateupdate() const {
  // @@protoc_insertion_point(field_get:message.Message.allStateUpdate)
  return has_allstateupdate()
      ? *msg_.allstateupdate_
      : *reinterpret_cast< ::message::AllStateUpdate*>(&::message::_AllStateUpdate_default_instance_);
}
inline ::message::AllStateUpdate* Message::mutable_allstateupdate() {
  if (!has_allstateupdate()) {
    clear_msg();
    set_has_allstateupdate();
    msg_.allstateupdate_ = new ::message::AllStateUpdate;
  }
  // @@protoc_insertion_point(field_mutable:message.Message.allStateUpdate)
  return msg_.allstateupdate_;
}

inline bool Message::has_msg() const {
  return msg_case() != MSG_NOT_SET;
}
inline void Message::clear_has_msg() {
  _oneof_case_[0] = MSG_NOT_SET;
}
inline Message::MsgCase Message::msg_case() const {
  return Message::MsgCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Response

// string status = 1;
inline void Response::clear_status() {
  status_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Response::status() const {
  // @@protoc_insertion_point(field_get:message.Response.status)
  return status_.GetNoArena();
}
inline void Response::set_status(const ::std::string& value) {
  
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:message.Response.status)
}
#if LANG_CXX11
inline void Response::set_status(::std::string&& value) {
  
  status_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:message.Response.status)
}
#endif
inline void Response::set_status(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:message.Response.status)
}
inline void Response::set_status(const char* value, size_t size) {
  
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:message.Response.status)
}
inline ::std::string* Response::mutable_status() {
  
  // @@protoc_insertion_point(field_mutable:message.Response.status)
  return status_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Response::release_status() {
  // @@protoc_insertion_point(field_release:message.Response.status)
  
  return status_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Response::set_allocated_status(::std::string* status) {
  if (status != NULL) {
    
  } else {
    
  }
  status_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), status);
  // @@protoc_insertion_point(field_set_allocated:message.Response.status)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace message

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_message_2eproto__INCLUDED
